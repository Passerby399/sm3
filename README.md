# SM3算法实现与优化报告

## 1. 算法概述

SM3是中国国家密码管理局发布的哈希算法标准，广泛应用于数字签名、消息认证、区块链等领域。其结构类似于SHA-256，采用Merkle-Damgård构架，具有良好的安全性和性能。

### 1.1 数学结构

SM3的核心包括：
- 消息填充与分块
- 消息扩展（消息调度）
- 压缩函数（64轮迭代）
- 输出置换

#### 1.2 主要参数

- 分组长度：512位（64字节）
- 哈希输出：256位（32字节）
- 初始向量（IV）：8个32位常量
- 轮常量（Tj）：前16轮为0x79CC4519，后48轮为0x7A879D8A

## 2. 算法流程与数学推导

### 2.1 消息填充

对输入消息进行填充，使其长度满足
```math
len \equiv 448 \pmod{512}
```
最后附加消息长度（64位）。

**填充步骤：**
1. 补一个`0x80`字节
2. 补零直到长度满足要求
3. 最后8字节为消息长度（单位：bit）

### 2.2 消息扩展

将每个512位分组扩展为68个32位字
```math
W_0, ..., W_{67}
```
再生成64个
```math
W'_j = W_j \oplus W_{j+4}
```

**扩展公式：**
```math
W_j =
\begin{cases}
M_j, & 0 \leq j < 16 \\
P_1(W_{j-16} \oplus W_{j-9} \oplus \text{ROTL}(W_{j-3}, 15)) \oplus \text{ROTL}(W_{j-13}, 7) \oplus W_{j-6}, & 16 \leq j < 68
\end{cases}
```

其中
```math
P_1(x) = x \oplus \text{ROTL}(x, 15) \oplus \text{ROTL}(x, 23)
```

### 2.3 压缩函数

每轮迭代更新8个状态变量
```math
A,B,C,D,E,F,G,H
```

**轮函数公式：**
```math
\begin{aligned}
SS_1 &= \text{ROTL}((\text{ROTL}(A,12) + E + \text{ROTL}(T_j, j \bmod 32)), 7) \\
SS_2 &= SS_1 \oplus \text{ROTL}(A,12) \\
TT_1 &= FF(A,B,C,j) + D + SS_2 + W'_j \\
TT_2 &= GG(E,F,G,j) + H + SS_1 + W_j \\
\end{aligned}
```

其中：
- `FF` 和 `GG` 为布尔函数，前16轮为异或，后48轮为混合与或
- 
```math
P_0(x) = x \oplus \text{ROTL}(x,9) \oplus \text{ROTL}(x,17)
```

每轮后状态变量循环移位，最终与初始向量异或得到输出。

## 3. 代码实现思路

### 3.1 基本实现

- 填充函数 `sm3_pad`：负责消息填充和长度附加
- 消息扩展 `sm3_message_expansion_basic`：实现消息调度
- 压缩函数 `sm3_compress_basic`：实现64轮迭代
- 哈希主流程 `sm3_hash_basic`：串联上述步骤，输出最终哈希

### 3.2 优化实现

- SIMD优化：利用SSE2指令加速消息扩展
- 循环展开：压缩函数每4轮一组，减少分支和提升性能
- 优化哈希主流程 `sm3_hash_optimized`：自动选择最优实现

### 3.3 长度扩展攻击

利用SM3的Merkle-Damgård结构，实现长度扩展攻击：
- 以原始哈希为初始向量，处理扩展消息
- 计算新哈希，验证攻击效果

### 3.4 Merkle树实现

- 叶子节点：每个节点存储SM3哈希
- 父节点：合并左右子节点哈希后再哈希
- 树构建：自底向上递归合并
- 存在性证明：生成叶子到根的兄弟节点哈希链
- 验证证明：逐层重算哈希，最终与根哈希比对

## 4. 关键实现细节

### 4.1 字节序处理

SM3标准采用大端序，代码中通过`__builtin_bswap32`进行转换，确保跨平台一致性。

### 4.2 内存管理

所有填充、扩展、树节点等均动态分配内存，使用`malloc`和`free`避免内存泄漏。

### 4.3 性能测试

通过`benchmark_sm3`函数，分别测试基本和优化实现的速度，并验证结果一致性。

## 5. 主要函数接口说明

- `sm3_hash_basic(data, len, digest)`：基础SM3哈希
- `sm3_hash_optimized(data, len, digest)`：优化SM3哈希
- `sm3_length_extension_attack(...)`：长度扩展攻击
- `build_merkle_tree(data, lengths, count)`：构建Merkle树
- `generate_existence_proof(tree, index, &proof, &proof_len)`：生成存在性证明
- `verify_existence_proof(...)`：验证存在性证明

## 6. 数学安全性分析

- **抗碰撞性**：SM3设计满足256位安全级别，未发现有效碰撞攻击
- **抗长度扩展攻击**：标准应用需防止直接暴露哈希值用于MAC等场景
- **Merkle树安全性**：依赖SM3哈希不可逆和抗碰撞性，保证成员证明安全

## 7. 性能评估

- 基本实现约2MB/s，优化实现可达10MB/s以上（视硬件和编译器优化）
- 支持大规模数据（如10万叶子节点的Merkle树）构建与验证

## 8. 应用场景

- 区块链数据完整性验证
- 数字签名与消息认证
- 零知识证明中的哈希承诺
- Merkle树成员证明

## 9. 总结

本项目实现了SM3哈希算法的基础与优化版本，支持长度扩展攻击演示和Merkle树应用，具备良好的性能和安全性。代码结构清晰，易于扩展和集成到实际应用中。
